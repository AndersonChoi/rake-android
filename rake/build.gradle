apply plugin: 'com.android.library'
apply plugin: 'maven'
apply plugin: 'idea'
apply plugin: 'jacoco-android'
apply plugin: 'com.github.kt3k.coveralls'

import java.util.regex.Pattern

version = '0.4.8' // TODO Release build 할 때 version 값을 반드시 확인한다.
group = 'com.skplanet.rake'
archivesBaseName = 'rake-android'

/**
 * 경로 파일 이름 관련 상수
 */
String CURRENT_PROJECT_DIR = "${rootProject.projectDir}/rake"
String TEMP_JAR = "${archivesBaseName}-${version}-withoutShuttle.jar"
String COMPLETE_JAR = "${archivesBaseName}-${version}.jar"
String DOCS_DIR = "${rootProject.projectDir}/docs/"
String CURRENT_VERSION_DOCS = (version.contains("SNAPSHOT")) ? "SNAPSHOT" : version
String RELEASE_DIR = "${rootProject.projectDir}/release"
String RELEASE_JAR_DIR = "$RELEASE_DIR/jar"
String DIR_AAR = "$CURRENT_PROJECT_DIR/build/outputs/aar"
String RELEASE_AAR = "${archivesBaseName}-release.aar"
String PATH_DEBUG_AAR = "$DIR_AAR/$RELEASE_AAR"
String DIR_TEST_APP_LIBS = "${rootProject.projectDir}/testApp/libs"
String DIR_EXAMPLE_APP_LIBS = "${rootProject.projectDir}/rake_example/libs"
String LIB_INCLUDED_DIR = "${CURRENT_PROJECT_DIR}/libs/included"
String BRANCH_NAME = "git rev-parse --abbrev-ref HEAD".execute().text.trim()

def logger = { String message -> println("[RAKE BUILDER] $message") }
def updateFile = { String path, Pattern regex, String replace ->
    def encoding = "UTF-8"
    def f = new File(path)

    String content = f.getText(encoding)
    def old = content.find(regex)
    content = content.replaceAll(regex, replace)

    assert(content.find(regex) == replace)
    f.write(content, encoding)

    logger "Replaced: \n$old -> $replace \n($path)"
}

/**
 * 빌드타임에 변수 또는 상수가 치환(replace) 되는 파일들
 */
String RAKE_ROOT_PACKAGE = "src/main/java/com/rake/android/rkmetrics";
String FILE_REPLACED_CONFIG = "${CURRENT_PROJECT_DIR}/$RAKE_ROOT_PACKAGE/config/RakeConfig.java"
String FILE_REPLACED_METRIC_LOGGER = "${CURRENT_PROJECT_DIR}/$RAKE_ROOT_PACKAGE/metric/MetricUtil.java"

String RELEASE_BRANCH = "release"
def isReleaseBranch = BRANCH_NAME.startsWith(RELEASE_BRANCH)
String VAR_BRANCH = "BUILD_CONSTANT_BRANCH";
Pattern REGEX_BRANCH = ~/String $VAR_BRANCH = "(.)*"/
String FILLED_BRANCH = "String $VAR_BRANCH = \"$BRANCH_NAME\""

String VAR_METRIC_TOKEN = "BUILD_CONSTANT_METRIC_TOKEN"
Pattern REGEX_METRIC_TOKEN_FILLED = ~/String $VAR_METRIC_TOKEN = "(.)*"/
String FILLED_METRIC_TOKEN_DEV = null

String VAR_RAKE_ENV = "BUILD_CONSTANT_ENV"
Pattern REGEX_RAKE_ENV = ~/RakeAPI.Env $VAR_RAKE_ENV = RakeAPI.Env(.)*;/
String FILLED_RAKE_ENV = "RakeAPI.Env $VAR_RAKE_ENV = RakeAPI.Env.DEV;"

/**
 * 빌드스크립트 시작
 */

android {
    compileSdkVersion 26
    buildToolsVersion '26.0.2'

    defaultConfig {
        minSdkVersion 14
        targetSdkVersion 26
        versionCode 1
        versionName "1.0"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
}

dependencies {
    compile fileTree(dir: 'libs/included', include: ['*.jar'])
    testCompile fileTree(dir: 'libs/test', include: ['*.jar'])

    testCompile 'junit:junit:4.12'
    testCompile 'org.assertj:assertj-core:3.8.0'
    testCompile 'com.github.tomakehurst:wiremock:1.55'
    testCompile 'ch.qos.logback:logback-core:1.2.3'
    testCompile 'ch.qos.logback:logback-classic:1.2.3'
    testCompile "org.robolectric:robolectric:3.0"
}

coveralls {
    def reportDir = "build/reports/jacoco/jacocoTestDebugUnitTestReport"
    jacocoReportPath "${CURRENT_PROJECT_DIR}/${reportDir}/jacocoTestDebugUnitTestReport.xml"
}

jacocoAndroidUnitTestReport {
    csv.enabled false
    html.enabled true
    xml.enabled true
}

configurations {
    jarArchives
}

uploadJarArchives {
    repositories {
        mavenDeployer {
            repository(url: 'http://mvn.skplanet.com/content/repositories/releases')
            snapshotRepository(url: 'http://mvn.skplanet.com/content/repositories/snapshots')
        }
    }
}

artifacts {
    jarArchives file: file("${RELEASE_JAR_DIR}/${COMPLETE_JAR}")
}

task updateVersionInSource(type: Copy) {
    def updateVersionInConfigFile = {

        String v = version.tokenize('-')[0]
        Pattern pattern = ~/"r0.5.0_c(.)*"/
        String  replace = "\"r0.5.0_c${v}\""
        String  path = FILE_REPLACED_CONFIG

        updateFile(path, pattern, replace)
    }

    /**
     * build.gradle 에 있는 버전을 이용해, RakeConfig.java 파일 내에 있는 버전을 매 빌드마다 변경
     */
    updateVersionInConfigFile();

}

task updateMetricToken(type: Copy) {

    def getMetricToken = {
        /**
         * 아래의 환경변수 및 상수 이름들은 MetricUtilTokenSpec.java 에 있는 이름과 동일해야 함
         */
        String ENV_METRIC_TOKEN_LIVE = "METRIC_TOKEN_LIVE";
        String ENV_METRIC_TOKEN_DEV = "METRIC_TOKEN_DEV";

        /* 환경변수 검증 */
        String METRIC_TOKEN_LIVE = System.getenv(ENV_METRIC_TOKEN_LIVE)
        String METRIC_TOKEN_DEV  = System.getenv(ENV_METRIC_TOKEN_DEV)

        if (null == METRIC_TOKEN_LIVE) throw new IllegalArgumentException("Env $ENV_METRIC_TOKEN_LIVE required");
        if (null == METRIC_TOKEN_DEV)  throw new IllegalArgumentException("Env $ENV_METRIC_TOKEN_DEV required");

        /* TOKEN 값 설정 */
        FILLED_METRIC_TOKEN_DEV = "String $VAR_METRIC_TOKEN = \"$METRIC_TOKEN_DEV\""
        String METRIC_TOKEN = null

        if (isReleaseBranch) METRIC_TOKEN = METRIC_TOKEN_LIVE
        else METRIC_TOKEN = METRIC_TOKEN_DEV

        return METRIC_TOKEN
    }


    def getFilledMetricToken = {
        String METRIC_TOKEN = getMetricToken()

        String FILLED_METRIC_TOKEN = "String $VAR_METRIC_TOKEN = \"$METRIC_TOKEN\""

        return FILLED_METRIC_TOKEN
    }

    def updateMetricToken =  {
        String FILLED_METRIC_TOKEN = getFilledMetricToken()
        /**
         * 소스 코드에 토큰을 노출하지 않기 위해서 TOKEN 값을 빌드타임에 환경변수에서 읽어와 덮어쓴다.
         * `build.gradle` 과 `MetricUtilTokenSpec.java` 를 참조할 것
         *
         * 후에 `release` 브랜치에서 LIVE TOKEN 이 기록되었는지 크로스 체크를 위해
         * BUILD_CONSTANT_BRANCH 값을 이용한다.
         */

        updateFile(FILE_REPLACED_METRIC_LOGGER, REGEX_BRANCH, FILLED_BRANCH) /* BUILD_CONSTANT_BRANCH 업데이트 */
        updateFile(FILE_REPLACED_METRIC_LOGGER, REGEX_METRIC_TOKEN_FILLED, FILLED_METRIC_TOKEN) /* BUILD_CONSTANT_METRIC_TOKEN 업데이트 */
    }

    /**
     * 환경변수 값을 이용해 MetricUtil.java 에 있는 Rake Client Metric 용 토큰을 빌드타임에 컴파일
     * 자세한 내용은 MetricUtil.java, MetricUtilTokenSpec.java 를 참조
     */

     updateMetricToken();
}

task updateRakeEnv(type: Copy) {
    def getRakeEnv = {

        String ENV_LIVE = "RakeAPI.Env $VAR_RAKE_ENV = RakeAPI.Env.LIVE;"
        String ENV_DEV  = "RakeAPI.Env $VAR_RAKE_ENV = RakeAPI.Env.DEV;"

        if (isReleaseBranch) return ENV_LIVE
        else return ENV_DEV
    }

    updateFile(FILE_REPLACED_METRIC_LOGGER, REGEX_RAKE_ENV, getRakeEnv())
}

gradle.projectsEvaluated { /* do something before compile */
    updateVersionInSource.execute()
    /** TODO uploadArchive 시에는 reset 해주어야 함 */
    updateMetricToken.execute()
}

task createJavadoc(type: Javadoc) {
    if (BRANCH_NAME.startsWith("gh-pages")) {
        source = android.sourceSets.main.java.srcDirs
        classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
        destinationDir = file("${DOCS_DIR}/$CURRENT_VERSION_DOCS")
        failOnError false
    }
}

tasks.build.doLast {

/* extract jar from AAR and create rake.jar without shuttle */
    task extractJarFromAar(type: Copy) {

        logger "Extracting ${TEMP_JAR} from ${PATH_DEBUG_AAR}"

        from zipTree(file(PATH_DEBUG_AAR))
        into DIR_AAR
        rename "classes.jar", TEMP_JAR
        exclude "R.txt", "assets", "aidl", "aapt/**/*", "res/**/*", "AndroidManifest.xml",
                "libs/**/*"
        includeEmptyDirs = false
    }

/* zip rake-android.jar with shuttle.jar */
    task zipWithShuttle(type: Zip) {

        /* constants */
        String shuttleJarNamePrefix = "RakeClientMetricSentinelShuttle"
        def shuttleJarNames = []

        /* logic */
        new File("${LIB_INCLUDED_DIR}").eachFile { file ->
            if (file.path.contains(shuttleJarNamePrefix))
                shuttleJarNames << file.path
        }

        if (shuttleJarNames.size > 1)
            throw new IllegalStateException("Multiple shuttle jar exists in ${LIB_INCLUDED_DIR}")
        else if (shuttleJarNames.size == 0)
            throw new IllegalStateException("Can not find shuttle jar in ${LIB_INCLUDED_DIR}")

        String shuttleJarName = shuttleJarNames[0]
        logger "Provided shuttle: ${shuttleJarName}"

        // merge crash-logger.jar with shuttle.jar
        from zipTree(file("${shuttleJarName}"))
        from zipTree(file("${DIR_AAR}/${TEMP_JAR}"))
        exclude ".gitkeep", "META-INF/", "${shuttleJarNamePrefix}.java"
        include "**/*"
        extension "jar"
        destinationDir file("${DIR_AAR}")
    }

    task copyCompleteJarToReleaseDir(type: Copy) {

        logger "Copying $DIR_AAR/$COMPLETE_JAR to ${RELEASE_JAR_DIR}/"

        from DIR_AAR
        include COMPLETE_JAR
        into RELEASE_JAR_DIR
    }

    task copyCompleteJarToTestApp(type: Copy) {

        logger "Copying $DIR_AAR/$COMPLETE_JAR to ${DIR_TEST_APP_LIBS}/"

        from DIR_AAR
        include COMPLETE_JAR
        into DIR_TEST_APP_LIBS


        logger "Copying $DIR_AAR/$COMPLETE_JAR to ${DIR_EXAMPLE_APP_LIBS}/"

        from DIR_AAR
        include COMPLETE_JAR
        into DIR_EXAMPLE_APP_LIBS
    }

    task initializeBuildConstant(type: Copy) {
        logger "initialize BUILD_CONSTANT"
        updateFile(FILE_REPLACED_METRIC_LOGGER, REGEX_METRIC_TOKEN_FILLED, FILLED_METRIC_TOKEN_DEV)
        updateFile(FILE_REPLACED_METRIC_LOGGER, REGEX_RAKE_ENV, FILLED_RAKE_ENV)
    }

    extractJarFromAar.execute();
    zipWithShuttle.execute();
    copyCompleteJarToTestApp.execute();

    if (BRANCH_NAME.startsWith("release")) {
        createJavadoc.execute()
        copyCompleteJarToReleaseDir.execute();
    }

    initializeBuildConstant.execute();
}
